-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Syntax.Grammar.Par
  ( happyError
  , myLexer
  , pExp
  , pType
  ) where

import Prelude

import qualified Syntax.Grammar.Abs
import Syntax.Grammar.Lex

}

%name pExp Exp
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)  }
  '!='     { PT _ (TS _ 2)  }
  '%'      { PT _ (TS _ 3)  }
  '('      { PT _ (TS _ 4)  }
  ')'      { PT _ (TS _ 5)  }
  '*'      { PT _ (TS _ 6)  }
  '+'      { PT _ (TS _ 7)  }
  ','      { PT _ (TS _ 8)  }
  '-'      { PT _ (TS _ 9)  }
  '->'     { PT _ (TS _ 10) }
  '/'      { PT _ (TS _ 11) }
  ';'      { PT _ (TS _ 12) }
  '<'      { PT _ (TS _ 13) }
  '<='     { PT _ (TS _ 14) }
  '=='     { PT _ (TS _ 15) }
  '>'      { PT _ (TS _ 16) }
  '>='     { PT _ (TS _ 17) }
  'Bool'   { PT _ (TS _ 18) }
  'Double' { PT _ (TS _ 19) }
  'L'      { PT _ (TS _ 20) }
  'R'      { PT _ (TS _ 21) }
  'and'    { PT _ (TS _ 22) }
  'cos'    { PT _ (TS _ 23) }
  'else'   { PT _ (TS _ 24) }
  'exp'    { PT _ (TS _ 25) }
  'false'  { PT _ (TS _ 26) }
  'fst'    { PT _ (TS _ 27) }
  'if'     { PT _ (TS _ 28) }
  'lam'    { PT _ (TS _ 29) }
  'left'   { PT _ (TS _ 30) }
  'match'  { PT _ (TS _ 31) }
  'or'     { PT _ (TS _ 32) }
  'rand()' { PT _ (TS _ 33) }
  'right'  { PT _ (TS _ 34) }
  'sin'    { PT _ (TS _ 35) }
  'snd'    { PT _ (TS _ 36) }
  'sqrt'   { PT _ (TS _ 37) }
  'then'   { PT _ (TS _ 38) }
  'true'   { PT _ (TS _ 39) }
  '{'      { PT _ (TS _ 40) }
  '}'      { PT _ (TS _ 41) }
  L_Ident  { PT _ (TV $$)   }
  L_doubl  { PT _ (TD $$)   }

%%

Ident :: { Syntax.Grammar.Abs.Ident }
Ident  : L_Ident { Syntax.Grammar.Abs.Ident $1 }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Exp :: { Syntax.Grammar.Abs.Exp }
Exp
  : Exp1 { $1 }
  | 'lam' Ident '->' Exp1 { Syntax.Grammar.Abs.Abstr $2 $4 }

Exp1 :: { Syntax.Grammar.Abs.Exp }
Exp1 : Exp2 { $1 }

Exp2 :: { Syntax.Grammar.Abs.Exp }
Exp2 : Exp3 { $1 }

Exp3 :: { Syntax.Grammar.Abs.Exp }
Exp3
  : Exp4 { $1 }
  | '(' Exp3 ',' Exp3 ')' { Syntax.Grammar.Abs.Tup $2 $4 }

Exp4 :: { Syntax.Grammar.Abs.Exp }
Exp4
  : Exp5 { $1 }
  | 'match' Exp4 '{' 'L' Ident '->' Exp5 ';' 'R' Ident '->' Exp5 '}' { Syntax.Grammar.Abs.Match $2 $5 $7 $10 $12 }

Exp5 :: { Syntax.Grammar.Abs.Exp }
Exp5
  : Exp6 { $1 }
  | 'if' Exp5 'then' Exp6 'else' Exp6 { Syntax.Grammar.Abs.Ite $2 $4 $6 }

Exp6 :: { Syntax.Grammar.Abs.Exp }
Exp6
  : Exp7 { $1 }
  | Exp6 'and' Exp7 { Syntax.Grammar.Abs.And $1 $3 }
  | Exp6 'or' Exp7 { Syntax.Grammar.Abs.Or $1 $3 }

Exp7 :: { Syntax.Grammar.Abs.Exp }
Exp7 : Exp8 { $1 } | '!' Exp8 { Syntax.Grammar.Abs.Not $2 }

Exp8 :: { Syntax.Grammar.Abs.Exp }
Exp8
  : Exp9 { $1 }
  | Exp8 '==' Exp9 { Syntax.Grammar.Abs.Eq $1 $3 }
  | Exp8 '<' Exp9 { Syntax.Grammar.Abs.Lt $1 $3 }
  | Exp8 '>' Exp9 { Syntax.Grammar.Abs.Gt $1 $3 }
  | Exp8 '!=' Exp9 { Syntax.Grammar.Abs.Neq $1 $3 }
  | Exp8 '<=' Exp9 { Syntax.Grammar.Abs.Leq $1 $3 }
  | Exp8 '>=' Exp9 { Syntax.Grammar.Abs.Geq $1 $3 }

Exp9 :: { Syntax.Grammar.Abs.Exp }
Exp9
  : Exp10 { $1 }
  | Exp9 '+' Exp10 { Syntax.Grammar.Abs.Add $1 $3 }
  | Exp9 '-' Exp10 { Syntax.Grammar.Abs.Sub $1 $3 }

Exp10 :: { Syntax.Grammar.Abs.Exp }
Exp10
  : Exp11 { $1 }
  | Exp10 '*' Exp11 { Syntax.Grammar.Abs.Mul $1 $3 }
  | Exp10 '/' Exp11 { Syntax.Grammar.Abs.Div $1 $3 }
  | Exp10 '%' Exp11 { Syntax.Grammar.Abs.Mod $1 $3 }

Exp11 :: { Syntax.Grammar.Abs.Exp }
Exp11 : Exp12 { $1 }

Exp12 :: { Syntax.Grammar.Abs.Exp }
Exp12
  : Exp13 { $1 }
  | '-' Exp11 { Syntax.Grammar.Abs.Min $2 }
  | 'sqrt' '(' Exp13 ')' { Syntax.Grammar.Abs.Sqrt $3 }
  | 'sin' '(' Exp13 ')' { Syntax.Grammar.Abs.Sin $3 }
  | 'cos' '(' Exp13 ')' { Syntax.Grammar.Abs.Cos $3 }
  | 'exp' '(' Exp13 ')' { Syntax.Grammar.Abs.EPow $3 }

Exp13 :: { Syntax.Grammar.Abs.Exp }
Exp13
  : Exp14 { $1 }
  | 'left' Exp14 { Syntax.Grammar.Abs.InL $2 }
  | 'right' Exp14 { Syntax.Grammar.Abs.InR $2 }
  | 'fst' Exp14 { Syntax.Grammar.Abs.Fst $2 }
  | 'snd' Exp14 { Syntax.Grammar.Abs.Snd $2 }

Exp14 :: { Syntax.Grammar.Abs.Exp }
Exp14 : Exp15 { $1 } | Exp14 Exp15 { Syntax.Grammar.Abs.App $1 $2 }

Exp15 :: { Syntax.Grammar.Abs.Exp }
Exp15
  : '(' Exp ')' { $2 }
  | Ident { Syntax.Grammar.Abs.Var $1 }
  | 'true' { Syntax.Grammar.Abs.BTrue }
  | 'false' { Syntax.Grammar.Abs.BFalse }
  | Double { Syntax.Grammar.Abs.DVal $1 }
  | 'rand()' { Syntax.Grammar.Abs.Rand }

Type :: { Syntax.Grammar.Abs.Type }
Type
  : Type1 { $1 }
  | Type '+' Type1 { Syntax.Grammar.Abs.TCoprod $1 $3 }

Type1 :: { Syntax.Grammar.Abs.Type }
Type1
  : Type2 { $1 } | Type1 '->' Type2 { Syntax.Grammar.Abs.TFun $1 $3 }

Type2 :: { Syntax.Grammar.Abs.Type }
Type2
  : Type3 { $1 }
  | '(' Type2 ',' Type2 ')' { Syntax.Grammar.Abs.TProd $2 $4 }

Type3 :: { Syntax.Grammar.Abs.Type }
Type3
  : '(' Type ')' { $2 }
  | 'Double' { Syntax.Grammar.Abs.TDouble }
  | 'Bool' { Syntax.Grammar.Abs.TBool }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

